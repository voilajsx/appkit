# AppKit API CLI Documentation

## Overview

The AppKit CLI provides a powerful command-line interface for creating and managing TypeScript backend APIs using Feature-Based Component Architecture (FBCA). It includes auto-discovery routing, full AppKit integration, automatic .env configuration, database support, and VoilaJSX documentation standards.

## Installation

```bash
npm install -g @voilajsx/appkit
```

## Commands

### `appkit create <project-name>`

Creates a new TypeScript backend API project with FBCA structure and automatic configuration.

**Usage:**
```bash
appkit create my-api
cd my-api
npm run dev
```

**What it creates:**
```
my-api/
├── package.json              # TypeScript dependencies & scripts
├── tsconfig.json             # TypeScript configuration (bundler resolution)
├── .env                      # Environment configuration (auto-generated)
└── src/api/
    ├── server.ts             # Main server with AppKit integration
    ├── lib/
    │   └── router.ts         # Auto-discovery FBCA router
    └── features/
        ├── greeting/         # Default greeting feature
        │   ├── greeting.route.ts    # Express routes
        │   ├── greeting.service.ts  # Business logic
        │   └── greeting.types.ts    # TypeScript interfaces
        └── auth/             # Default auth feature
            ├── auth.route.ts        # Express routes
            ├── auth.service.ts      # Business logic
            └── auth.types.ts        # TypeScript interfaces
```

**New Features ✨:**
- ✅ **Automatic .env generation** with PORT, DATABASE_URL, and app configuration
- ✅ **TypeScript compilation fixes** with proper module resolution
- ✅ **Enhanced tsconfig.json** with bundler module resolution and strict typing
- ✅ **Root routes** for `/` and `/api` with endpoint discovery
- ✅ **Production-ready** configuration out of the box

**Features included:**
- ✅ Full TypeScript setup with proper build process
- ✅ AppKit integration (logger, config, error handling)
- ✅ Auto-discovery routing system
- ✅ Automatic .env configuration with port and database settings
- ✅ Default greeting and auth features for immediate testing
- ✅ VoilaJSX comment standards with @llm-rule annotations
- ✅ Production-ready configuration

**Available endpoints after creation:**
- `GET /` - Application welcome with endpoint discovery
- `GET /health` - Health check with system status
- `GET /api` - API overview with discovered features list
- `GET /api/greeting` - Basic greeting
- `GET /api/greeting/:name` - Personalized greeting
- `GET /api/auth` - Authentication status

### `appkit generate feature <feature-name> [--db]`

Generates a new feature with route, service, and types files. Now supports database integration!

**Basic Usage:**
```bash
appkit generate feature user
```

**Database Usage:**
```bash
appkit generate feature product --db
```

**What `--db` flag does ✨:**
- ✅ **Creates database-enabled templates** with Prisma client integration
- ✅ **Automatic Prisma setup** including schema generation
- ✅ **Database model creation** with proper TypeScript types
- ✅ **Smart .env handling** (doesn't duplicate existing DATABASE_URL)
- ✅ **Automated Prisma commands** (db push, generate)
- ✅ **Full CRUD operations** with AppKit database module

**Database Feature Structure:**
```
src/api/features/product/
├── product.route.ts     # Express routes with full CRUD endpoints
├── product.service.ts   # Business logic with Prisma integration
└── product.types.ts     # TypeScript interfaces matching Prisma model
```

**Generated endpoints with `--db`:**
- `GET /api/product` - Get all records
- `POST /api/product` - Create new record
- `GET /api/product/:id` - Get record by ID
- `PUT /api/product/:id` - Update record
- `DELETE /api/product/:id` - Delete record

## Environment Configuration (.env)

**Auto-generated .env file:**
```bash
# Environment Configuration for my-api
# Generated by AppKit CLI

# Server Configuration
PORT=3000
NODE_ENV=development

# Database Configuration
DATABASE_URL="file:./dev.db"

# Application Configuration
APP_NAME=my-api
API_VERSION=1.0.0

# Logging
LOG_LEVEL=info
```

**Benefits:**
- ✅ **Consistent configuration** across all projects
- ✅ **Database ready** out of the box
- ✅ **Port management** via environment variables
- ✅ **Development/production** environment separation

## Database Integration with `--db`

### What happens when using `--db`:

1. **Prisma Schema Generation:**
   ```prisma
   model Product {
     id          String    @id @default(cuid())
     name        String
     description String?
     tenant_id   String?   // Mandatory for AppKit multi-tenant support
     createdAt   DateTime  @default(now())
     updatedAt   DateTime  @updatedAt
     @@map("products")
   }
   ```

2. **AppKit Database Integration:**
   ```typescript
   import { databaseClass } from '@voilajsx/appkit/database';

   const db = await databaseClass.get();
   const items = await db.product.findMany();
   ```

3. **Full CRUD Service:**
   ```typescript
   export const productService = {
     async getAll(): Promise<ProductResponse[]> { /* ... */ },
     async getById(id: string): Promise<ProductResponse> { /* ... */ },
     async create(data: ProductCreateRequest): Promise<ProductResponse> { /* ... */ },
     async update(id: string, data: ProductUpdateRequest): Promise<ProductResponse> { /* ... */ },
     async delete(id: string): Promise<void> { /* ... */ }
   };
   ```

4. **Automated Setup:**
   - Creates `prisma/schema.prisma` (if doesn't exist)
   - Adds model to existing schema
   - Ensures DATABASE_URL in .env
   - Runs `prisma db push` automatically
   - Runs `prisma generate` automatically

## Project Structure

### FBCA (Feature-Based Component Architecture)

Each feature is self-contained in its own directory:

```
src/api/features/<feature-name>/
├── <feature-name>.route.ts    # HTTP endpoints
├── <feature-name>.service.ts  # Business logic (with optional DB integration)
└── <feature-name>.types.ts    # TypeScript interfaces
```

### Auto-Discovery

The router automatically discovers and loads features:
- Scans `src/api/features/` directory
- Looks for `{featureName}.route.ts` files
- Mounts at `/api/{featureName}`
- Hot-reload friendly with nodemon
- Lists discovered features at `GET /api`

## Development

### Scripts

```bash
npm run dev         # Start development server with hot-reload
npm run start       # Start production server
npm run build       # Build TypeScript to JavaScript
npm run start:prod  # Start built production server
```

### TypeScript Compilation ✨

**Fixed TypeScript Issues:**
- ✅ **Module resolution** set to "bundler" for AppKit compatibility
- ✅ **Strict typing** enabled with proper error handling
- ✅ **AppKit type compatibility** resolved
- ✅ **ES modules** properly configured
- ✅ **Prisma types** integrated seamlessly

### Adding New Features

#### Manual Feature Creation:

1. **Create feature directory:**
   ```bash
   mkdir src/api/features/user
   ```

2. **Create types file (`user.types.ts`):**
   ```typescript
   /**
    * User Feature Type Definitions - Shared interfaces and types
    * @module my-api/user-types
    * @file src/api/features/user/user.types.ts
    *
    * @llm-rule WHEN: Need type safety for user feature data structures
    * @llm-rule AVOID: Defining types inline - reduces reusability and consistency
    * @llm-rule NOTE: Shared across service and route layers for type consistency
    */

   export interface UserResponse {
     id: string;
     name: string;
     email: string;
     createdAt: string;
     updatedAt: string;
   }

   export interface UserCreateRequest {
     name: string;
     email: string;
   }

   export interface UserUpdateRequest {
     name?: string;
     email?: string;
   }
   ```

3. **Create service file (`user.service.ts`):**
   ```typescript
   /**
    * User Feature Service - Business logic with AppKit integration
    * @module my-api/user-service
    * @file src/api/features/user/user.service.ts
    *
    * @llm-rule WHEN: Need business logic layer with validation, logging, and config
    * @llm-rule AVOID: Direct database calls from routes - always use service layer
    * @llm-rule NOTE: Demonstrates AppKit logger, config, and error patterns for FBCA
    */

   import { loggerClass } from '@voilajsx/appkit/logger';
   import { configClass } from '@voilajsx/appkit/config';
   import { errorClass } from '@voilajsx/appkit/error';
   import type { UserResponse, UserCreateRequest } from './user.types.js';

   const logger = loggerClass.get('user');
   const config = configClass.get();
   const error = errorClass.get();

   export const userService = {
     async getAll(): Promise<UserResponse[]> {
       try {
         logger.info('Processing get all users request');
         // Your business logic here
         return [];
       } catch (err) {
         logger.error('Failed to get users', { error: err });
         throw error.serverError('Failed to retrieve users');
       }
     }
   };
   ```

4. **Create route file (`user.route.ts`):**
   ```typescript
   /**
    * User Feature Routes - Express endpoints with AppKit integration
    * @module my-api/user-routes
    * @file src/api/features/user/user.route.ts
    *
    * @llm-rule WHEN: Need HTTP endpoints for user feature with error handling
    * @llm-rule AVOID: Adding routes without asyncRoute wrapper - breaks error handling
    * @llm-rule NOTE: Auto-discovered by router.ts, exports default Express router
    */

   import express from 'express';
   import { errorClass } from '@voilajsx/appkit/error';
   import { loggerClass } from '@voilajsx/appkit/logger';
   import { userService } from './user.service.js';

   const router = express.Router();
   const error = errorClass.get();
   const logger = loggerClass.get('user-routes');

   router.get('/', error.asyncRoute(async (_req, res) => {
     logger.info('GET /api/user request received');
     const result = await userService.getAll();
     res.json(result);
   }));

   export default router;
   ```

#### Database Feature Creation:

**Use the CLI for instant database-enabled features:**
```bash
appkit generate feature user --db
```

This automatically creates all files with:
- ✅ **Prisma model** in schema.prisma
- ✅ **Database service methods** with full CRUD
- ✅ **Proper TypeScript types** from Prisma
- ✅ **Complete REST endpoints**
- ✅ **AppKit database integration**

## AppKit Integration

### Database (NEW ✨)

```typescript
import { databaseClass } from '@voilajsx/appkit/database';

// Get database client with automatic tenant filtering
const db = await databaseClass.get();

// Use Prisma client directly
const users = await db.user.findMany({
  orderBy: { createdAt: 'desc' }
});

// Transform for response
const result = users.map(user => ({
  ...user,
  createdAt: user.createdAt.toISOString(),
  updatedAt: user.updatedAt.toISOString()
}));
```

### Logger

```typescript
import { loggerClass } from '@voilajsx/appkit/logger';
const logger = loggerClass.get('feature-name');

logger.info('Processing request', { userId: '123' });
logger.error('Request failed', { error: err });
```

### Error Handling

```typescript
import { errorClass } from '@voilajsx/appkit/error';
const error = errorClass.get();

// In routes - use asyncRoute wrapper
router.get('/', error.asyncRoute(async (req, res) => {
  // Your code here
}));

// In services - throw AppKit errors
throw error.badRequest('Invalid input data');
throw error.notFound('User not found');
throw error.serverError('Database connection failed');
```

### Configuration

```typescript
import { configClass } from '@voilajsx/appkit/config';
const config = configClass.get();

const port = config.get('server.port', process.env.PORT || 3000);
const dbUrl = config.get('database.url', process.env.DATABASE_URL);
const appName = config.get('app.name', process.env.APP_NAME);
```

## VoilaJSX Documentation Standards

All files include @llm-rule annotations for AI-friendly documentation:

```typescript
/**
 * Feature description
 * @module project-name/module-name
 * @file src/path/to/file.ts
 *
 * @llm-rule WHEN: When to use this module/function
 * @llm-rule AVOID: What to avoid or common mistakes
 * @llm-rule NOTE: Additional context (optional)
 */
```

## Testing

### Manual Testing

```bash
# Health check
curl http://localhost:3000/health

# Root and API discovery
curl http://localhost:3000/
curl http://localhost:3000/api

# Feature endpoints
curl http://localhost:3000/api/greeting
curl http://localhost:3000/api/greeting/world

# Database endpoints (if using --db)
curl http://localhost:3000/api/product
curl -X POST http://localhost:3000/api/product -H "Content-Type: application/json" -d '{"name":"Test Product"}'
```

### Database Testing with `--db`

```bash
# Create a record
curl -X POST http://localhost:3000/api/product \
  -H "Content-Type: application/json" \
  -d '{"name": "Laptop", "description": "High performance laptop"}'

# Get all records
curl http://localhost:3000/api/product

# Get specific record
curl http://localhost:3000/api/product/cluv123abc

# Update record
curl -X PUT http://localhost:3000/api/product/cluv123abc \
  -H "Content-Type: application/json" \
  -d '{"name": "Gaming Laptop", "description": "Updated description"}'

# Delete record
curl -X DELETE http://localhost:3000/api/product/cluv123abc
```

### Integration with Testing Frameworks

The generated structure works seamlessly with:
- Jest/Vitest for unit testing
- Supertest for API testing
- Any testing framework that supports ES modules

## Production Deployment

1. **Build the project:**
   ```bash
   npm run build
   ```

2. **Start production server:**
   ```bash
   npm run start:prod
   ```

3. **Environment variables:**
   ```bash
   NODE_ENV=production
   PORT=3000
   DATABASE_URL="postgresql://user:pass@host:5432/db"
   APP_NAME=my-api
   LOG_LEVEL=info
   ```

## Best Practices

### File Organization
- Keep features self-contained
- Use descriptive, consistent naming
- Follow the three-file pattern (route, service, types)
- Use `--db` flag for database-enabled features

### Database Best Practices (NEW ✨)
- Always use AppKit database class for consistency
- Include `tenant_id` field for multi-tenant support
- Transform date objects to ISO strings in responses
- Use proper TypeScript types from Prisma
- Implement proper validation in services

### Error Handling
- Always use `error.asyncRoute()` in routes
- Use AppKit error classes in services
- Include contextual logging
- Handle database errors gracefully

### TypeScript
- Define interfaces in `.types.ts` files
- Use proper return type annotations
- Import types with `type` keyword
- Leverage Prisma-generated types for database models

### Logging
- Log request start/completion in routes
- Include relevant context in log messages
- Use appropriate log levels (info, warn, error)
- Log database operations for debugging

## Troubleshooting

### Feature not auto-discovered
- Ensure file is named `{featureName}.route.ts`
- Check that it exports a default Express router
- Verify file is in `src/api/features/{featureName}/` directory
- Check server logs for discovery messages

### TypeScript compilation errors ✨
- **Fixed:** Module resolution issues with AppKit modules
- **Fixed:** Missing Express types in route handlers
- **Fixed:** Prisma client type compatibility
- Run `npm run build` to check for remaining issues

### Database integration issues
- Ensure `DATABASE_URL` is set in .env
- Check that Prisma client is generated (`npx prisma generate`)
- Verify database schema is applied (`npx prisma db push`)
- Review Prisma logs for connection issues

### Import errors
- Use `.js` extensions in imports (TypeScript requirement)
- Check tsconfig.json `moduleResolution` setting (should be "bundler")
- Ensure proper relative/absolute paths

### AppKit errors
- Verify @voilajsx/appkit is installed
- Check that AppKit modules are initialized correctly
- Review error logs for specific AppKit messages

## Examples

### Complete Database-Enabled Feature

Generate a complete CRUD API with one command:

```bash
appkit generate feature order --db
```

This creates:

**order.types.ts:**
```typescript
export interface OrderResponse {
  id: string;
  name: string;
  description: string | null;
  tenant_id: string | null;
  createdAt: string;
  updatedAt: string;
}

export interface OrderCreateRequest {
  name: string;
  description?: string;
}

export interface OrderUpdateRequest {
  name?: string;
  description?: string;
}
```

**order.service.ts:**
```typescript
import { databaseClass } from '@voilajsx/appkit/database';
import type { Order } from '@prisma/client';

export const orderService = {
  async getAll(): Promise<OrderResponse[]> {
    const db = await databaseClass.get();
    const items = await db.order.findMany({
      orderBy: { createdAt: 'desc' }
    });

    return items.map((item: Order) => ({
      ...item,
      createdAt: item.createdAt.toISOString(),
      updatedAt: item.updatedAt.toISOString()
    }));
  },

  async create(data: OrderCreateRequest): Promise<OrderResponse> {
    const db = await databaseClass.get();
    const item = await db.order.create({
      data: {
        name: data.name.trim(),
        description: data.description?.trim() || null,
      }
    });

    return {
      ...item,
      createdAt: item.createdAt.toISOString(),
      updatedAt: item.updatedAt.toISOString()
    };
  }
  // ... other CRUD methods
};
```

**Generated Prisma Model:**
```prisma
model Order {
  id          String    @id @default(cuid())
  name        String
  description String?
  tenant_id   String?   // Mandatory for AppKit multi-tenant support
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@map("orders")
}
```

### Advanced Patterns

```typescript
// Service with comprehensive validation
async createUser(data: UserCreateRequest): Promise<UserResponse> {
  // Validate input
  if (!data.name || data.name.length < 2) {
    throw error.badRequest('Name must be at least 2 characters');
  }

  if (!data.email || !isValidEmail(data.email)) {
    throw error.badRequest('Valid email is required');
  }

  // Database operation with AppKit integration
  const db = await databaseClass.get();
  const user = await db.user.create({
    data: {
      name: data.name.trim(),
      email: data.email.toLowerCase().trim()
    }
  });

  logger.info('User created successfully', { userId: user.id });

  return {
    ...user,
    createdAt: user.createdAt.toISOString(),
    updatedAt: user.updatedAt.toISOString()
  };
}

// Route with proper error handling and validation
router.post('/', error.asyncRoute(async (req, res) => {
  logger.info('POST /api/user request received', { body: req.body });

  const userData = req.body;
  const result = await userService.createUser(userData);

  res.status(201).json(result);
}));
```

---

**Generated with AppKit CLI v2.0 - Enhanced with Database Support, TypeScript Fixes, and Auto-Configuration**